package alx.common.util{  /**   * Abstract random number generator.   * @author Alexander Volkov   * @version 1.0   */  public class CAbstractRandom   implements IRandom  {    /** Seed*/    private var m_nSeed:uint;    /**     * Creates new random generator.     * @param nSeed uint     */    public function CAbstractRandom( nSeed:uint = 0):void    {      if ( nSeed == 0)        this.setSeed(( Math.random() * uint.MAX_VALUE));      else        this.setSeed( nSeed);    }    /**     * Generates next random number in [0;1).     * @return Number     */    protected function generate():Number    {      throw Error( 'generate must be implemented');    }    public function getSeed():uint    {      return this.m_nSeed;    }    public function setSeed( nSeed:uint):void    {      this.m_nSeed = nSeed;    }        public function nextUint( nMin:uint = 0, nMax:uint = uint.MAX_VALUE):uint    {      if ( nMax < nMin)        throw Error( 'Max can\'t be less than than Min');      return ( this.generate() * ( nMax - nMin) + nMin);    }    public function nextFloat( nMin:Number = 0, nMax:Number = Number.MAX_VALUE):Number    {      if ( isNaN( nMin) || isNaN( nMax))        throw ArgumentError( 'Max & Min can\'t be NaN');      if ( !isFinite( nMin) || !isFinite( nMax))        throw ArgumentError( 'Max & Min can\'t be Infinity');      if ( nMax < nMin)        throw ArgumentError( 'Max can\'t be less than than Min');      return ( this.generate() * ( nMax - nMin) + nMin);    }    public function nextInt( nMin:int = 0, nMax:int = int.MAX_VALUE):int    {      return Math.floor( this.nextFloat( nMin, nMax));    }    public function nextBoolean( nChance:Number = 0.5):Boolean    {      if ( isNaN( nChance))        throw ArgumentError( 'Chance can\'t be NaN');      if ( !isFinite( nChance))        throw ArgumentError( 'Chance can\'t be Infinity');      if (( nChance < 0) || ( nChance > 1))        throw ArgumentError( 'Chance should be in [0;1]');      return ( this.generate() < nChance);    }    public function nextSign( nChance:Number = 0.5):int    {      return this.nextBoolean( nChance) ? 1 : -1;    }    public function nextBit( nChance:Number = 0.5):int    {      return this.nextBoolean( nChance) ? 1 : 0;    }  }}