package alx.common.util{  /**   * Random number generator.   * @author Alexander Volkov   * @version 1.1   */  public class CRandom   {    /** internal needs constant*/    private static const MULT:uint = 0xBBDD9CCD;    /** internal needs constant*/    private static const OFFSET:uint = 0xB;    /** Seed*/    private var m_nSeed:uint;    /**     * Creates new random generator.     * @param nSeed uint     */    public function CRandom( nSeed:uint = 0):void    {      if ( nSeed == 0)        this.setSeed(( Math.random() * uint.MAX_VALUE));      else        this.setSeed( nSeed);    }    /**     * Gets current seed value.     * @return uint     */    public function getSeed():uint    {      return ( this.m_nSeed ^ CRandom.MULT);    }    /**     * Sets current seed value.     * @return uint     */    public function setSeed( nSeed:uint):void    {      this.m_nSeed = nSeed ^ CRandom.MULT;          }    /**     * Generates next random number.     * @param nBits uint     * @return uint     */    protected function next( nBits:uint):uint    {      this.m_nSeed = this.m_nSeed * CRandom.MULT + CRandom.OFFSET;      return ( this.m_nSeed >>> ( 32 - nBits));    }    /**     * Generates next random number in [0;1).     * @return Number     */    protected function generate():Number    {      return this.next( 32) / uint.MAX_VALUE;    }    /**     * Generates next integer value in [nMin;nMax).     * @param nMin uint     * @param nMax uint     * @return uint     * @throws Error if arguments are not valid     */    public function nextUint( nMin:uint = 0, nMax:uint = uint.MAX_VALUE):uint    {      if ( nMax < nMin)        throw Error( 'Max can\'t be less than than Min');      return ( this.generate() * ( nMax - nMin) + nMin);    }    /**     * Generates next random float in [nMin;nMax).     * @param nMin Number     * @param nMax Number     * @return Number     * @throws Error if arguments are not valid     */    public function nextFloat( nMin:Number = 0, nMax:Number = Number.MAX_VALUE):Number    {      if ( isNaN( nMin) || isNaN( nMax))        throw ArgumentError( 'Max & Min can\'t be NaN');      if ( !isFinite( nMin) || !isFinite( nMax))        throw ArgumentError( 'Max & Min can\'t be Infinity');      if ( nMax < nMin)        throw ArgumentError( 'Max can\'t be less than than Min');      return ( this.generate() * ( nMax - nMin) + nMin);    }     /**     * Generates next integer value in [nMin;nMax).     * @param nMin int     * @param nMax int     * @return int     * @throws Error if arguments are not valid     */    public function nextInt( nMin:int = 0, nMax:int = int.MAX_VALUE):int    {      return Math.floor( this.nextFloat( nMin, nMax));    }    /**     * Generates next boolean value with a certain chance.     * @param nChance Number     * @return Boolean     * @throws Error if argument is not valid     */    public function nextBoolean( nChance:Number = 0.5):Boolean    {      if ( isNaN( nChance))        throw ArgumentError( 'Chance can\'t be NaN');      if ( !isFinite( nChance))        throw ArgumentError( 'Chance can\'t be Infinity');      if (( nChance < 0) || ( nChance > 1))        throw ArgumentError( 'Chance should be in [0;1]');      return ( this.generate() < nChance);    }    /**     * Generates next sign (1 or -1) with a certain chance.     * @param nChance Number     * @return int     * @throws Error if argument is not valid     */    public function nextSign( nChance:Number = 0.5):int    {      return this.nextBoolean( nChance) ? 1 : -1;    }    /**     * Generates next bit (1 or 0) with a certain chance.     * @param nChance Number     * @return int     * @throws Error if argument is not valid     */    public function nextBit( nChance:Number = 0.5):int    {      return this.nextBoolean( nChance) ? 1 : 0;    }  }}